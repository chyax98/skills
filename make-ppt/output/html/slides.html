<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>reveal-md</title>
    <link rel="shortcut icon" href="./favicon.ico" />
    <link rel="stylesheet" href="./dist/reset.css" />
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/black.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/base16/zenburn.css" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section data-markdown data-separator="\r?\n---\r?\n" data-separator-vertical="\r?\n----\r?\n">
          <textarea data-template>
            

# TypeScript 2025 完整教程

入门 + 基础 + 中级

---

## 课程大纲

**第一部分：入门篇**
1. TypeScript 简介
2. 环境搭建
3. 第一个程序

<!-- .element: class="fragment" -->

**第二部分:基础篇**
4. 类型系统基础
5. 函数与接口
6. 类与对象

<!-- .element: class="fragment" -->

**第三部分:中级篇**
7. 泛型编程
8. 高级类型
9. 模块系统
10. 实战应用

<!-- .element: class="fragment" -->

---

# 第一部分：入门篇

---

## 第 1 章：TypeScript 简介

---

### 什么是 TypeScript

**TypeScript = JavaScript + 类型系统**

<!-- .element: class="fragment" -->

- 由 Microsoft 开发的开源语言
- JavaScript 的超集
- 编译为纯 JavaScript
- 2012 年首次发布

<!-- .element: class="fragment" -->

---

### TypeScript 核心特性

**静态类型检查**
- 编译时捕获错误
- 智能代码提示
- 减少运行时 bug

<!-- .element: class="fragment" -->

**现代 ES 特性**
- 支持 ES2024+
- 向下编译兼容
- 提前使用新特性

<!-- .element: class="fragment" -->

**强大工具链**
- IDE 深度集成
- 实时错误检测
- 重构支持

<!-- .element: class="fragment" -->

---

### TypeScript 5.x 新特性 (2025)

\`\`\`typescript
// 1. 装饰器标准化
class Calculator {
  @log
  add(a: number, b: number): number {
    return a + b;
  }
}

// 2. const 类型参数
function createArray<const T>(items: readonly T[]): T[] {
  return [...items];
}

const numbers = createArray([1, 2, 3] as const);
\`\`\`

---

### 为什么选择 TypeScript

**2025 年生态优势**

<!-- .element: class="fragment" -->

- ✅ React、Vue、Angular 官方推荐
- ✅ 85% 新项目选择 TS
- ✅ GitHub 项目年增长 40%+
- ✅ 薪资普遍高 15-20%

<!-- .element: class="fragment" -->

---

### 提前发现错误

\`\`\`typescript
// ❌ JavaScript - 运行时才报错
function calculateTotal(price, quantity) {
  return price * quantity;
}
calculateTotal("100", 5); // "100100100100100"

// ✅ TypeScript - 编译时就报错
function calculateTotal(price: number, quantity: number): number {
  return price * quantity;
}
calculateTotal("100", 5); // 编译错误
\`\`\`

---

### 更好的代码提示

\`\`\`typescript
interface User {
  id: number;
  name: string;
  email: string;
  createdAt: Date;
}

function greetUser(user: User) {
  // IDE 自动提示所有属性
  console.log(\`Hello, \${user.name}\`);
  // 输入 user. 后自动补全
}
\`\`\`

---

### TypeScript vs JavaScript

| 特性 | JavaScript | TypeScript |
|-----|-----------|------------|
| 类型系统 | 动态 | 静态 |
| 错误检查 | 运行时 | 编译时 |
| IDE 支持 | 基础 | 深度集成 |
| 学习曲线 | 平缓 | 需学习类型 |

---

### 应用场景

**前端应用**
- React / Vue / Angular
- 单页应用 (SPA)

<!-- .element: class="fragment" -->

**后端开发**
- Node.js / Express
- Nest.js / Deno / Bun

<!-- .element: class="fragment" -->

**移动端 & 桌面**
- React Native
- Electron

<!-- .element: class="fragment" -->

---

## 第 2 章：环境搭建

---

### Node.js 安装

**推荐版本: v20+ LTS**

<!-- .element: class="fragment" -->

**Windows**
\`\`\`bash
# 下载官方安装包
https://nodejs.org/
\`\`\`

<!-- .element: class="fragment" -->

**macOS**
\`\`\`bash
brew install node@20
\`\`\`

<!-- .element: class="fragment" -->

**Linux**
\`\`\`bash
curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -
sudo apt-get install -y nodejs
\`\`\`

<!-- .element: class="fragment" -->

---

### 包管理器选择 (2025)

**npm** - 默认选择
- Node.js 自带
- 生态最成熟

<!-- .element: class="fragment" -->

**pnpm** - 强烈推荐
- 节省 50%+ 磁盘空间
- 安装速度快 2-3 倍
- 避免幽灵依赖

<!-- .element: class="fragment" -->

**Bun** - 未来之星
- 极致性能(快 10-20 倍)
- 原生支持 TypeScript
- 一体化工具

<!-- .element: class="fragment" -->

---

### 安装 TypeScript

\`\`\`bash
# 全局安装(学习推荐)
npm install -g typescript

# 项目级安装(生产推荐)
npm install -D typescript

# 验证安装
tsc --version  # Version 5.x.x
\`\`\`

---

### tsconfig.json 配置

\`\`\`bash
# 创建配置文件
npx tsc --init
\`\`\`

\`\`\`json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "outDir": "./dist",
    "rootDir": "./src"
  }
}
\`\`\`

---

### VS Code 配置

**必备插件**

<!-- .element: class="fragment" -->

1. **ESLint** - 代码质量检查
2. **Prettier** - 代码格式化
3. **Error Lens** - 实时错误显示
4. **Path Intellisense** - 路径补全

<!-- .element: class="fragment" -->

**推荐设置**
\`\`\`json
{
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "typescript.updateImportsOnFileMove.enabled": "always"
}
\`\`\`

<!-- .element: class="fragment" -->

---

## 第 3 章：第一个 TypeScript 程序

---

### Hello World

\`\`\`bash
# 1. 创建项目
mkdir hello-typescript && cd hello-typescript

# 2. 初始化项目
npm init -y

# 3. 安装 TypeScript
npm install -D typescript

# 4. 创建配置
npx tsc --init
\`\`\`

---

### 编写代码

\`\`\`typescript
// hello.ts
function greet(name: string): string {
  return \`Hello, \${name}!\`;
}

const userName: string = "TypeScript";
const message: string = greet(userName);

console.log(message);  // Hello, TypeScript!
\`\`\`

---

### 编译和运行

\`\`\`bash
# 方法 1: 编译后运行
npx tsc hello.ts
node hello.js

# 方法 2: 使用 ts-node
npm install -D ts-node
npx ts-node hello.ts

# 方法 3: 使用 tsx (推荐)
npm install -D tsx
npx tsx hello.ts
\`\`\`

---

### 基本类型: string

\`\`\`typescript
// 字符串声明
let username: string = "张三";
let email: string = 'zhang@example.com';

// 模板字符串
let greeting: string = \`你好, \${username}!\`;

// 多行字符串
let multiLine: string = \`
  这是第一行
  这是第二行
\`;

console.log(greeting);  // 你好, 张三!
\`\`\`

---

### 基本类型: number

\`\`\`typescript
// 整数和浮点数
let age: number = 25;
let price: number = 99.99;

// 科学计数法
let bigNumber: number = 1e6;  // 1000000

// 特殊数值
let infinity: number = Infinity;
let notANumber: number = NaN;

// 数学运算
console.log(10 + 3);   // 13
console.log(10 % 3);   // 1
console.log(10 ** 3);  // 1000
\`\`\`

---

### 基本类型: boolean

\`\`\`typescript
// 布尔值
let isStudent: boolean = true;
let isAdult: boolean = false;

// 比较运算
let isEqual: boolean = 10 === 10;  // true
let isGreater: boolean = 5 > 3;    // true

// 逻辑运算
let hasTicket: boolean = true;
let isWeekend: boolean = false;

let canGoToMovie: boolean = hasTicket && isWeekend;  // false
let canRelax: boolean = hasTicket || isWeekend;      // true
\`\`\`

---

### 类型注解语法

\`\`\`typescript
// 变量类型注解
let username: string = "张三";
let age: number = 25;

// 类型推断(可省略注解)
let city = "北京";  // 自动推断为 string

// 函数参数注解
function add(a: number, b: number): number {
  return a + b;
}

// 箭头函数
const multiply = (a: number, b: number): number => a * b;
\`\`\`

---

### 常见编译错误

**错误 1: 类型不匹配**
\`\`\`typescript
let age: number = "25";  // ❌ 错误

// 修复
let age: number = 25;    // ✅ 正确
\`\`\`

<!-- .element: class="fragment" -->

**错误 2: 隐式 any**
\`\`\`typescript
function greet(name) {  // ❌ 错误

// 修复
function greet(name: string) {  // ✅ 正确
\`\`\`

<!-- .element: class="fragment" -->

---

# 第二部分：基础篇

---

## 第 4 章：类型系统基础

---

### 数组类型

\`\`\`typescript
// 方式 1: 类型[]
let numbers: number[] = [1, 2, 3, 4, 5];
let names: string[] = ["Alice", "Bob", "Charlie"];

// 方式 2: Array<类型>
let scores: Array<number> = [90, 85, 92];
let tags: Array<string> = ["ts", "js", "react"];

// 数组操作
numbers.push(6);           // ✅ 正确
// numbers.push("7");      // ❌ 错误: 类型不匹配
\`\`\`

---

### 元组类型 (Tuple)

\`\`\`typescript
// 固定长度、固定类型的数组
let user: [string, number, boolean];

user = ["Alice", 25, true];  // ✅ 正确
// user = [25, "Alice", true];  // ❌ 错误: 类型顺序不对

// 访问元组元素
console.log(user[0]);  // "Alice"
console.log(user[1]);  // 25

// 解构赋值
let [name, age, isActive] = user;
\`\`\`

---

### 枚举类型: 数字枚举

\`\`\`typescript
enum Direction {
  Up,      // 0
  Down,    // 1
  Left,    // 2
  Right    // 3
}

let dir: Direction = Direction.Up;

console.log(Direction.Up);     // 0
console.log(Direction[0]);     // "Up"

// 自定义起始值
enum Status {
  Pending = 1,
  Success,     // 2
  Failed       // 3
}
\`\`\`

---

### 枚举类型: 字符串枚举

\`\`\`typescript
enum LogLevel {
  Error = "ERROR",
  Warning = "WARN",
  Info = "INFO",
  Debug = "DEBUG"
}

function log(level: LogLevel, message: string) {
  console.log(\`[\${level}] \${message}\`);
}

log(LogLevel.Error, "发生错误");
// 输出: [ERROR] 发生错误
\`\`\`

---

### any 类型

\`\`\`typescript
// any 类型可以赋任意值
let value: any = 42;
value = "hello";     // ✅ 可以
value = true;        // ✅ 可以
value = { x: 10 };   // ✅ 可以

// ⚠️ 慎用: 失去类型检查
value.foo();         // 不会报错,但运行时可能崩溃
value.bar.baz;       // 不会报错
\`\`\`

<!-- .element: class="fragment" -->

**使用场景**
- 迁移 JS 代码到 TS
- 处理动态内容
- 第三方库没有类型声明

<!-- .element: class="fragment" -->

---

### unknown 类型

\`\`\`typescript
let value: unknown = 42;

// ❌ 不能直接使用
// console.log(value.toFixed(2));

// ✅ 需要类型检查后使用
if (typeof value === "number") {
  console.log(value.toFixed(2));  // ✅ 安全
}

// unknown 比 any 更安全
let anyValue: any = "hello";
anyValue.toFixed();  // 不报错,运行时崩溃

let unknownValue: unknown = "hello";
// unknownValue.toFixed();  // ❌ 编译错误
\`\`\`

---

### never 类型

\`\`\`typescript
// 永远不会返回的函数
function throwError(message: string): never {
  throw new Error(message);
}

// 死循环
function infiniteLoop(): never {
  while (true) {}
}

// 类型收窄
function processValue(value: string | number) {
  if (typeof value === "string") {
    return value.toUpperCase();
  } else if (typeof value === "number") {
    return value.toFixed(2);
  } else {
    // 这里 value 是 never 类型
    const _exhaustiveCheck: never = value;
  }
}
\`\`\`

---

## 第 5 章：函数与接口

---

### 函数类型定义

\`\`\`typescript
// 完整函数定义
function add(a: number, b: number): number {
  return a + b;
}

// 箭头函数
const multiply = (a: number, b: number): number => a * b;

// 函数表达式
const divide: (a: number, b: number) => number = function(a, b) {
  return a / b;
};
\`\`\`

---

### 可选参数与默认参数

\`\`\`typescript
// 可选参数(使用 ?)
function greet(name: string, greeting?: string): string {
  if (greeting) {
    return \`\${greeting}, \${name}!\`;
  }
  return \`Hello, \${name}!\`;
}

greet("Alice");              // "Hello, Alice!"
greet("Alice", "Good morning");  // "Good morning, Alice!"

// 默认参数
function calculatePrice(price: number, taxRate: number = 0.1): number {
  return price * (1 + taxRate);
}

calculatePrice(100);      // 110
calculatePrice(100, 0.2); // 120
\`\`\`

---

### 剩余参数 (Rest Parameters)

\`\`\`typescript
// 剩余参数必须是数组类型
function sum(...numbers: number[]): number {
  return numbers.reduce((total, n) => total + n, 0);
}

console.log(sum(1, 2, 3));        // 6
console.log(sum(1, 2, 3, 4, 5));  // 15

// 结合普通参数
function buildName(firstName: string, ...restOfName: string[]): string {
  return firstName + " " + restOfName.join(" ");
}

console.log(buildName("Joseph", "Samuel", "Lucas"));
// "Joseph Samuel Lucas"
\`\`\`

---

### 函数重载 (Overloading)

\`\`\`typescript
// 重载签名
function reverse(x: string): string;
function reverse(x: number): number;

// 实现签名
function reverse(x: string | number): string | number {
  if (typeof x === "string") {
    return x.split("").reverse().join("");
  } else {
    return Number(x.toString().split("").reverse().join(""));
  }
}

console.log(reverse("hello"));  // "olleh"
console.log(reverse(12345));    // 54321
\`\`\`

---

### 接口 (Interface) 定义

\`\`\`typescript
// 定义对象接口
interface User {
  id: number;
  name: string;
  email: string;
  age: number;
}

// 使用接口
const user: User = {
  id: 1,
  name: "Alice",
  email: "alice@example.com",
  age: 25
};

function displayUser(user: User): void {
  console.log(\`\${user.name} (\${user.email})\`);
}
\`\`\`

---

### 可选属性与只读属性

\`\`\`typescript
interface User {
  readonly id: number;     // 只读属性
  name: string;
  email: string;
  age?: number;           // 可选属性
  phone?: string;         // 可选属性
}

const user: User = {
  id: 1,
  name: "Alice",
  email: "alice@example.com"
  // age 和 phone 可以省略
};

// user.id = 2;  // ❌ 错误: id 是只读的
user.name = "Bob";  // ✅ 可以修改
\`\`\`

---

### 索引签名

\`\`\`typescript
// 字符串索引签名
interface StringDictionary {
  [key: string]: string;
}

const colors: StringDictionary = {
  primary: "#007bff",
  secondary: "#6c757d",
  success: "#28a745"
};

// 数字索引签名
interface NumberArray {
  [index: number]: number;
}

const fibonacci: NumberArray = [1, 1, 2, 3, 5, 8, 13];
\`\`\`

---

### 接口继承

\`\`\`typescript
// 基础接口
interface Animal {
  name: string;
  age: number;
}

// 继承接口
interface Dog extends Animal {
  breed: string;
  bark(): void;
}

const myDog: Dog = {
  name: "旺财",
  age: 3,
  breed: "金毛",
  bark() {
    console.log("汪汪汪!");
  }
};
\`\`\`

---

### 函数接口

\`\`\`typescript
// 定义函数类型的接口
interface SearchFunc {
  (source: string, subString: string): boolean;
}

// 使用函数接口
const mySearch: SearchFunc = function(src, sub) {
  return src.indexOf(sub) !== -1;
};

console.log(mySearch("hello world", "world"));  // true
console.log(mySearch("hello world", "TypeScript"));  // false
\`\`\`

---

## 第 6 章：类与对象

---

### 类的定义与构造函数

\`\`\`typescript
class Person {
  // 属性
  name: string;
  age: number;

  // 构造函数
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }

  // 方法
  greet(): void {
    console.log(\`你好, 我是 \${this.name}, \${this.age} 岁\`);
  }
}

const person = new Person("Alice", 25);
person.greet();  // 你好, 我是 Alice, 25 岁
\`\`\`

---

### 访问修饰符: public

\`\`\`typescript
class Person {
  public name: string;  // 公有属性(默认)

  constructor(name: string) {
    this.name = name;
  }

  public greet(): void {  // 公有方法
    console.log(\`Hello, \${this.name}\`);
  }
}

const person = new Person("Alice");
console.log(person.name);  // ✅ 可以访问
person.greet();            // ✅ 可以访问
\`\`\`

---

### 访问修饰符: private

\`\`\`typescript
class BankAccount {
  private balance: number;  // 私有属性

  constructor(initialBalance: number) {
    this.balance = initialBalance;
  }

  public deposit(amount: number): void {
    this.balance += amount;  // ✅ 类内可访问
  }

  public getBalance(): number {
    return this.balance;  // ✅ 类内可访问
  }
}

const account = new BankAccount(1000);
// console.log(account.balance);  // ❌ 错误: 私有属性
account.deposit(500);              // ✅ 可以
console.log(account.getBalance()); // ✅ 1500
\`\`\`

---

### 访问修饰符: protected

\`\`\`typescript
class Animal {
  protected name: string;  // 受保护属性

  constructor(name: string) {
    this.name = name;
  }
}

class Dog extends Animal {
  bark(): void {
    console.log(\`\${this.name} 汪汪汪!\`);  // ✅ 子类可访问
  }
}

const dog = new Dog("旺财");
dog.bark();  // 旺财 汪汪汪!
// console.log(dog.name);  // ❌ 错误: 受保护属性
\`\`\`

---

### readonly 修饰符

\`\`\`typescript
class Person {
  readonly id: number;  // 只读属性
  name: string;

  constructor(id: number, name: string) {
    this.id = id;      // ✅ 构造函数中可赋值
    this.name = name;
  }

  updateName(newName: string): void {
    this.name = newName;     // ✅ 普通属性可修改
    // this.id = 123;        // ❌ 错误: 只读属性不可修改
  }
}
\`\`\`

---

### getter 和 setter

\`\`\`typescript
class Person {
  private _age: number = 0;

  get age(): number {
    return this._age;
  }

  set age(value: number) {
    if (value < 0) {
      throw new Error("年龄不能为负数");
    }
    this._age = value;
  }
}

const person = new Person();
person.age = 25;  // 调用 setter
console.log(person.age);  // 调用 getter: 25

// person.age = -5;  // 抛出错误
\`\`\`

---

### 静态成员

\`\`\`typescript
class MathUtils {
  static PI: number = 3.14159;  // 静态属性

  static add(a: number, b: number): number {  // 静态方法
    return a + b;
  }

  static square(x: number): number {
    return x * x;
  }
}

// 通过类名访问,不需要实例化
console.log(MathUtils.PI);        // 3.14159
console.log(MathUtils.add(5, 3)); // 8
console.log(MathUtils.square(4)); // 16
\`\`\`

---

### 类的继承 (extends)

\`\`\`typescript
// 父类
class Animal {
  name: string;

  constructor(name: string) {
    this.name = name;
  }

  move(distance: number = 0): void {
    console.log(\`\${this.name} 移动了 \${distance} 米\`);
  }
}

// 子类
class Dog extends Animal {
  bark(): void {
    console.log("汪汪汪!");
  }
}

const dog = new Dog("旺财");
dog.bark();      // 汪汪汪!
dog.move(10);    // 旺财 移动了 10 米
\`\`\`

---

### 方法重写与 super

\`\`\`typescript
class Animal {
  name: string;

  constructor(name: string) {
    this.name = name;
  }

  move(distance: number = 0): void {
    console.log(\`\${this.name} 移动了 \${distance} 米\`);
  }
}

class Horse extends Animal {
  // 重写父类方法
  move(distance: number = 45): void {
    console.log("奔跑中...");
    super.move(distance);  // 调用父类方法
  }
}

const horse = new Horse("闪电");
horse.move();  // 奔跑中... 闪电 移动了 45 米
\`\`\`

---

### 抽象类和抽象方法

\`\`\`typescript
// 抽象类不能被实例化
abstract class Shape {
  abstract getArea(): number;  // 抽象方法

  // 普通方法
  describe(): void {
    console.log(\`面积: \${this.getArea()}\`);
  }
}

class Circle extends Shape {
  constructor(private radius: number) {
    super();
  }

  // 必须实现抽象方法
  getArea(): number {
    return Math.PI * this.radius ** 2;
  }
}

const circle = new Circle(5);
circle.describe();  // 面积: 78.54
\`\`\`

---

### 类实现接口

\`\`\`typescript
interface Printable {
  print(): void;
}

interface Loggable {
  log(message: string): void;
}

// 类可以实现多个接口
class Document implements Printable, Loggable {
  print(): void {
    console.log("打印文档");
  }

  log(message: string): void {
    console.log(\`日志: \${message}\`);
  }
}

const doc = new Document();
doc.print();            // 打印文档
doc.log("文档已创建");  // 日志: 文档已创建
\`\`\`

---

# 第三部分：中级篇

---

## 第 7 章：泛型编程

---

### 泛型的概念

**问题: 代码重复**
\`\`\`typescript
function getStringValue(value: string): string {
  return value;
}

function getNumberValue(value: number): number {
  return value;
}
\`\`\`

<!-- .element: class="fragment" -->

**解决: 使用泛型**
\`\`\`typescript
function getValue<T>(value: T): T {
  return value;
}

const str = getValue<string>("hello");
const num = getValue<number>(42);
\`\`\`

<!-- .element: class="fragment" -->

---

### 泛型函数

\`\`\`typescript
// 泛型函数定义
function identity<T>(arg: T): T {
  return arg;
}

// 使用方式 1: 显式指定类型
const str = identity<string>("hello");
const num = identity<number>(42);

// 使用方式 2: 类型推断
const value1 = identity("world");  // 推断为 string
const value2 = identity(100);      // 推断为 number
\`\`\`

---

### 泛型数组

\`\`\`typescript
function getFirstElement<T>(arr: T[]): T | undefined {
  return arr[0];
}

// 或者使用 Array<T> 语法
function getLastElement<T>(arr: Array<T>): T | undefined {
  return arr[arr.length - 1];
}

const first = getFirstElement([1, 2, 3]);      // number | undefined
const last = getLastElement(["a", "b", "c"]); // string | undefined
\`\`\`

---

### 泛型接口

\`\`\`typescript
interface Box<T> {
  value: T;
  getValue(): T;
  setValue(value: T): void;
}

const numberBox: Box<number> = {
  value: 42,
  getValue() {
    return this.value;
  },
  setValue(value: number) {
    this.value = value;
  }
};

console.log(numberBox.getValue());  // 42
\`\`\`

---

### 泛型类

\`\`\`typescript
class Stack<T> {
  private items: T[] = [];

  push(item: T): void {
    this.items.push(item);
  }

  pop(): T | undefined {
    return this.items.pop();
  }

  peek(): T | undefined {
    return this.items[this.items.length - 1];
  }

  isEmpty(): boolean {
    return this.items.length === 0;
  }
}

const stack = new Stack<number>();
stack.push(1);
stack.push(2);
console.log(stack.pop());  // 2
\`\`\`

---

### 泛型约束 (extends)

\`\`\`typescript
interface HasLength {
  length: number;
}

// T 必须有 length 属性
function logLength<T extends HasLength>(arg: T): void {
  console.log(arg.length);
}

logLength("hello");        // ✅ 5
logLength([1, 2, 3]);      // ✅ 3
logLength({ length: 10 }); // ✅ 10
// logLength(123);         // ❌ 错误: number 没有 length
\`\`\`

---

### 多泛型参数

\`\`\`typescript
function pair<T, U>(first: T, second: U): [T, U] {
  return [first, second];
}

const p1 = pair<string, number>("age", 25);
const p2 = pair("name", "Alice");  // 类型推断

// 泛型键值对
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const user = { name: "Alice", age: 25 };
const name = getProperty(user, "name");  // string
const age = getProperty(user, "age");    // number
\`\`\`

---

### 泛型实战: API 请求封装

\`\`\`typescript
interface ApiResponse<T> {
  code: number;
  data: T;
  message: string;
}

async function request<T>(url: string): Promise<ApiResponse<T>> {
  const response = await fetch(url);
  return response.json();
}

// 使用
interface User {
  id: number;
  name: string;
}

const response = await request<User>("/api/user/1");
console.log(response.data.name);  // 类型安全!
\`\`\`

---

## 第 8 章：高级类型

---

### 联合类型 (Union Types)

\`\`\`typescript
// 值可以是多种类型之一
type StringOrNumber = string | number;

let value: StringOrNumber;
value = "hello";  // ✅
value = 42;       // ✅
// value = true;  // ❌ 错误

function printId(id: string | number): void {
  if (typeof id === "string") {
    console.log(id.toUpperCase());
  } else {
    console.log(id.toFixed(2));
  }
}

printId("abc123");  // ABC123
printId(123);       // 123.00
\`\`\`

---

### 交叉类型 (Intersection Types)

\`\`\`typescript
interface Person {
  name: string;
  age: number;
}

interface Employee {
  employeeId: number;
  department: string;
}

// 同时具有两个接口的所有属性
type Staff = Person & Employee;

const staff: Staff = {
  name: "Alice",
  age: 25,
  employeeId: 1001,
  department: "Engineering"
};
\`\`\`

---

### 类型别名 (Type Alias)

\`\`\`typescript
// 为类型创建别名
type ID = string | number;
type Point = { x: number; y: number };
type Callback = (data: string) => void;

// 使用类型别名
let userId: ID = 123;
let point: Point = { x: 10, y: 20 };

const handleData: Callback = (data) => {
  console.log(data);
};
\`\`\`

---

### 类型断言 (Type Assertion)

\`\`\`typescript
// 方式 1: as 语法
const value: any = "hello";
const length: number = (value as string).length;

// 方式 2: <> 语法(不推荐,与 JSX 冲突)
const length2: number = (<string>value).length;

// 实际应用
const input = document.getElementById("myInput") as HTMLInputElement;
input.value = "Hello";

// 双重断言(不推荐)
const num = (value as any) as number;
\`\`\`

---

### 字面量类型

\`\`\`typescript
// 字符串字面量类型
type Direction = "up" | "down" | "left" | "right";

function move(direction: Direction): void {
  console.log(\`移动方向: \${direction}\`);
}

move("up");     // ✅
// move("top");  // ❌ 错误

// 数字字面量类型
type DiceRoll = 1 | 2 | 3 | 4 | 5 | 6;

function rollDice(): DiceRoll {
  return (Math.floor(Math.random() * 6) + 1) as DiceRoll;
}
\`\`\`

---

### 映射类型 (Mapped Types)

\`\`\`typescript
interface Person {
  name: string;
  age: number;
  email: string;
}

// 将所有属性变为可选
type PartialPerson = {
  [K in keyof Person]?: Person[K];
};

// 将所有属性变为只读
type ReadonlyPerson = {
  readonly [K in keyof Person]: Person[K];
};

const person: PartialPerson = {
  name: "Alice"
  // age 和 email 可选
};
\`\`\`

---

### 条件类型 (Conditional Types)

\`\`\`typescript
// T extends U ? X : Y
type IsString<T> = T extends string ? true : false;

type A = IsString<string>;   // true
type B = IsString<number>;   // false

// 实用示例: 提取函数返回值类型
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

function getUser() {
  return { name: "Alice", age: 25 };
}

type User = ReturnType<typeof getUser>;
// { name: string; age: number }
\`\`\`

---

### 工具类型: Partial<T>

\`\`\`typescript
interface User {
  name: string;
  age: number;
  email: string;
}

// 将所有属性变为可选
type PartialUser = Partial<User>;

const user: PartialUser = {
  name: "Alice"
  // age 和 email 可选
};

// 实际应用: 更新函数
function updateUser(user: User, updates: Partial<User>): User {
  return { ...user, ...updates };
}
\`\`\`

---

### 工具类型: Required<T>

\`\`\`typescript
interface User {
  name: string;
  age?: number;
  email?: string;
}

// 将所有属性变为必需
type RequiredUser = Required<User>;

const user: RequiredUser = {
  name: "Alice",
  age: 25,      // 必需
  email: "alice@example.com"  // 必需
};
\`\`\`

---

### 工具类型: Pick<T, K>

\`\`\`typescript
interface User {
  id: number;
  name: string;
  age: number;
  email: string;
}

// 只选择指定的属性
type UserPreview = Pick<User, "id" | "name">;

const preview: UserPreview = {
  id: 1,
  name: "Alice"
  // age 和 email 被排除
};
\`\`\`

---

### 工具类型: Omit<T, K>

\`\`\`typescript
interface User {
  id: number;
  name: string;
  age: number;
  password: string;
}

// 排除指定的属性
type PublicUser = Omit<User, "password">;

const publicUser: PublicUser = {
  id: 1,
  name: "Alice",
  age: 25
  // password 被排除
};
\`\`\`

---

### 工具类型: Record<K, T>

\`\`\`typescript
// 创建键值对类型
type Role = "admin" | "user" | "guest";

type RolePermissions = Record<Role, string[]>;

const permissions: RolePermissions = {
  admin: ["read", "write", "delete"],
  user: ["read", "write"],
  guest: ["read"]
};
\`\`\`

---

### 工具类型: Exclude & Extract

\`\`\`typescript
// Exclude: 从 T 中排除 U
type T1 = Exclude<"a" | "b" | "c", "a">;  // "b" | "c"
type T2 = Exclude<string | number, string>;  // number

// Extract: 从 T 中提取 U
type T3 = Extract<"a" | "b" | "c", "a" | "f">;  // "a"
type T4 = Extract<string | number, string>;  // string
\`\`\`

---

## 第 9 章：模块与命名空间

---

### ES6 模块系统

\`\`\`typescript
// math.ts - 命名导出
export function add(a: number, b: number): number {
  return a + b;
}

export function subtract(a: number, b: number): number {
  return a - b;
}

export const PI = 3.14159;

// app.ts - 导入
import { add, subtract, PI } from './math';

console.log(add(5, 3));  // 8
console.log(PI);         // 3.14159
\`\`\`

---

### 默认导出 vs 命名导出

\`\`\`typescript
// user.ts - 默认导出
export default class User {
  constructor(public name: string) {}
}

// utils.ts - 命名导出
export const VERSION = "1.0.0";
export function log(message: string) {
  console.log(message);
}

// app.ts - 导入
import User from './user';  // 默认导出
import { VERSION, log } from './utils';  // 命名导出

const user = new User("Alice");
log(\`Version: \${VERSION}\`);
\`\`\`

---

### @types 包的使用

\`\`\`bash
# 安装常用库的类型声明
npm install -D @types/node
npm install -D @types/express
npm install -D @types/react
npm install -D @types/lodash
\`\`\`

\`\`\`typescript
// 自动获得类型支持
import express from 'express';
import _ from 'lodash';

const app = express();  // 有完整的类型提示

app.get('/', (req, res) => {
  res.send('Hello World');
});
\`\`\`

---

## 第 10 章：实战应用 (2025)

---

### TypeScript + React

\`\`\`typescript
import React, { useState } from 'react';

interface TodoItem {
  id: number;
  text: string;
  completed: boolean;
}

const TodoApp: React.FC = () => {
  const [todos, setTodos] = useState<TodoItem[]>([]);

  const addTodo = (text: string) => {
    const newTodo: TodoItem = {
      id: Date.now(),
      text,
      completed: false
    };
    setTodos([...todos, newTodo]);
  };

  return <div>{/* UI 代码 */}</div>;
};
\`\`\`

---

### TypeScript + Vue 3

\`\`\`typescript
<script setup lang="ts">
import { ref, computed } from 'vue';

interface User {
  id: number;
  name: string;
  email: string;
}

const users = ref<User[]>([]);
const selectedUser = ref<User | null>(null);

const userCount = computed(() => users.value.length);

function addUser(user: User) {
  users.value.push(user);
}
</script>
\`\`\`

---

### 类型安全的 API 开发

\`\`\`typescript
// 定义 API 类型
interface ApiResponse<T> {
  code: number;
  data: T;
  message: string;
}

interface User {
  id: number;
  name: string;
  email: string;
}

// API 客户端
class ApiClient {
  async getUser(id: number): Promise<ApiResponse<User>> {
    const response = await fetch(\`/api/users/\${id}\`);
    return response.json();
  }
}
\`\`\`

---

### 性能优化建议

**编译性能**
- 启用 \`incremental\` 编译
- 使用 \`skipLibCheck\`
- 合理划分 \`include/exclude\`

<!-- .element: class="fragment" -->

**运行时性能**
- TypeScript 不影响运行时
- 编译为 ES2022+ 更高效
- 使用 esbuild/swc 替代 tsc

<!-- .element: class="fragment" -->

**类型系统**
- 避免过度使用 \`any\`
- 合理使用泛型约束
- 利用类型推断

<!-- .element: class="fragment" -->

---

## 总结与展望

---

### 学习回顾

**入门篇 ✅**
- TypeScript 基础概念
- 环境搭建
- 基本类型系统

<!-- .element: class="fragment" -->

**基础篇 ✅**
- 数组、元组、枚举
- 函数与接口
- 类与继承

<!-- .element: class="fragment" -->

**中级篇 ✅**
- 泛型编程
- 高级类型
- 模块系统
- 实战应用

<!-- .element: class="fragment" -->

---

### 2025 年最佳实践

1. **严格模式优先**: 启用 \`strict\`
2. **类型优先**: 避免 \`any\`
3. **工具类型**: 善用 \`Partial\`、\`Pick\` 等
4. **模块化**: 使用 ES Modules
5. **类型声明**: 为第三方库编写 \`.d.ts\`
6. **测试**: 使用 Vitest/Jest
7. **格式化**: ESLint + Prettier
8. **构建工具**: esbuild / Vite

---

### 学习资源

**官方资源**
- [TypeScript 官网](https://www.typescriptlang.org/)
- [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/)
- [TypeScript Playground](https://www.typescriptlang.org/play)

<!-- .element: class="fragment" -->

**社区资源**
- [GitHub](https://github.com/microsoft/TypeScript)
- [Stack Overflow](https://stackoverflow.com/questions/tagged/typescript)
- [TypeScript 中文网](https://www.tslang.cn/)

<!-- .element: class="fragment" -->

**实践平台**
- [Type Challenges](https://github.com/type-challenges/type-challenges)
- [Exercism](https://exercism.org/tracks/typescript)
- [LeetCode](https://leetcode.com/)

<!-- .element: class="fragment" -->

---

## 感谢观看！

**TypeScript - 让 JavaScript 更强大**

<!-- .element: class="fragment" -->

祝你的 TypeScript 学习之旅顺利！

<!-- .element: class="fragment" -->

          </textarea>
        </section>
      </div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./mermaid/dist/mermaid.min.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        slideNumber: true,
        highlight: {
          highlightOnLoad: false
        },
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"_":["output/slides.md"],"static":"output/html","theme":"black"}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
      Reveal.addEventListener('ready', function (event) {
        const blocks = Reveal.getRevealElement().querySelectorAll('pre code:not(.mermaid)');
        const hlp = Reveal.getPlugin('highlight');
        blocks.forEach(hlp.highlightBlock);
      });
    </script>

    <script>
      const mermaidOptions = extend({ startOnLoad: false }, {});
      mermaid.startOnLoad = false;
      mermaid.initialize(mermaidOptions);
      const cb = function (event) {
        mermaid.init(mermaidOptions, '.stack.present > .present pre code.mermaid');
        mermaid.init(mermaidOptions, '.slides > .present:not(.stack) pre code.mermaid');
      }
      Reveal.addEventListener('ready', cb);
      Reveal.addEventListener('slidetransitionend', cb);
    </script>
  </body>
</html>
